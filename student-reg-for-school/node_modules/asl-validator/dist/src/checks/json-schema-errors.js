"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonSchemaErrors = void 0;
var ajv_1 = __importDefault(require("ajv"));
var paths_json_1 = __importDefault(require("../schemas/paths.json"));
var choice_json_1 = __importDefault(require("../schemas/choice.json"));
var fail_json_1 = __importDefault(require("../schemas/fail.json"));
var parallel_json_1 = __importDefault(require("../schemas/parallel.json"));
var pass_json_1 = __importDefault(require("../schemas/pass.json"));
var base_state_machine_json_1 = __importDefault(require("../schemas/base-state-machine.json"));
var state_machine_json_1 = __importDefault(require("../schemas/state-machine.json"));
var state_json_1 = __importDefault(require("../schemas/state.json"));
var succeed_json_1 = __importDefault(require("../schemas/succeed.json"));
var task_json_1 = __importDefault(require("../schemas/task.json"));
var wait_json_1 = __importDefault(require("../schemas/wait.json"));
var map_json_1 = __importDefault(require("../schemas/map.json"));
var errors_json_1 = __importDefault(require("../schemas/errors.json"));
var types_1 = require("../types");
var asl_path_validator_1 = require("asl-path-validator");
var formats_1 = require("./formats");
var jsonSchemaErrors = function (definition, options) {
    var ajv = new ajv_1.default({
        schemas: [
            paths_json_1.default,
            choice_json_1.default,
            fail_json_1.default,
            parallel_json_1.default,
            pass_json_1.default,
            base_state_machine_json_1.default,
            state_machine_json_1.default,
            state_json_1.default,
            succeed_json_1.default,
            task_json_1.default,
            wait_json_1.default,
            map_json_1.default,
            errors_json_1.default,
        ],
        allowUnionTypes: true,
    });
    if (options.checkPaths) {
        (0, asl_path_validator_1.registerAll)(ajv);
    }
    else {
        ajv.addFormat("asl_path", function () { return true; });
        ajv.addFormat("asl_ref_path", function () { return true; });
        ajv.addFormat("asl_payload_template", function () { return true; });
    }
    if (options.checkArn) {
        ajv.addFormat("asl_arn", formats_1.isArnFormatValid);
    }
    else {
        ajv.addFormat("asl_arn", function () { return true; });
    }
    ajv.validate("http://asl-validator.cloud/state-machine.json#", definition);
    // the use of oneOf can generate a lot of errors since it'll test
    // the value against each of the types and report its wrong on all.
    //
    // instance paths are suitable for error reporting and AJV will generate
    // these for us in their errors. The challenge is which to show when there
    // are multiple.
    //
    // for example, given the simplest example with a one-step definition with only
    // a Pass state. Introducing a typo for the OutputPath expression generates
    // 9 errors from AJV.
    //
    if (!ajv.errors) {
        return [];
    }
    // console.error(JSON.stringify(ajv.errors))
    // select the error with the deepest path
    var selectedErrors = [];
    var deepest = 0;
    ajv.errors.forEach(function (error) {
        var instancePath = error.instancePath;
        var depth = instancePath.split("/").length;
        if (depth === deepest) {
            selectedErrors.push(error);
        }
        else if (depth > deepest) {
            selectedErrors = [error];
        }
        deepest = Math.max(deepest, depth);
    });
    // if there is a oneOf keyword error, then remove the
    // other non-format related errors before proceeding
    var instancePathsWithOneOfKeyword = new Set();
    selectedErrors
        .filter(function (error) { return error.keyword === "oneOf"; })
        .forEach(function (error) {
        instancePathsWithOneOfKeyword.add(error.instancePath);
    });
    return (selectedErrors
        .filter(function (error) {
        return error.keyword === "oneOf" ||
            !instancePathsWithOneOfKeyword.has(error.instancePath);
    })
        .map(function (error) {
        var _a;
        return ({
            "Error code": types_1.StateMachineErrorCode.SchemaValidationFailed,
            Message: "".concat(error.instancePath, " is invalid. ").concat((_a = error.message) !== null && _a !== void 0 ? _a : ""),
            schemaError: {
                instancePath: error.instancePath,
                schemaPath: decodeURIComponent(error.schemaPath),
            },
        });
    })
        // avoid returning a list of errors with duplicates
        // this filter will only return items if they don't already appear in an earlier position in the array
        .filter(function (v, i, a) {
        return (a.findIndex(function (v2) {
            var _a, _b;
            // duplicates are based on the schemaPath and instancePath
            return (v2.schemaError.schemaPath === ((_a = v.schemaError) === null || _a === void 0 ? void 0 : _a.schemaPath) &&
                v2.schemaError.instancePath === ((_b = v.schemaError) === null || _b === void 0 ? void 0 : _b.instancePath));
        }) === i);
    }));
};
exports.jsonSchemaErrors = jsonSchemaErrors;
